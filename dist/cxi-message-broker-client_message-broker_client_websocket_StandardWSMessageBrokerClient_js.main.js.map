{"version":3,"file":"cxi-message-broker-client_message-broker_client_websocket_StandardWSMessageBrokerClient_js.main.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACjlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA","sources":["webpack://bottar-ai/../cxi-message-broker-client/message-broker/client-factory/StandardClientFactory.js","webpack://bottar-ai/../cxi-message-broker-client/message-broker/client/ClientTypes.js","webpack://bottar-ai/../cxi-message-broker-client/message-broker/client/websocket/AbstractWSMessageBrokerClient.js","webpack://bottar-ai/../cxi-message-broker-client/message-broker/client/websocket/BrokerMessage.js","webpack://bottar-ai/../cxi-message-broker-client/message-broker/client/websocket/StandardWSMessageBrokerClient.js","webpack://bottar-ai/../cxi-message-broker-client/message-broker/logger/Logger.js","webpack://bottar-ai/../cxi-message-broker-client/message-broker/logger/LoggerFactory.js","webpack://bottar-ai/../cxi-message-broker-client/message-broker/utils/ClientUtils.js","webpack://bottar-ai/../cxi-message-broker-client/message-broker/utils/NetworkUtils.js","webpack://bottar-ai/../cxi-message-broker-client/message-broker/utils/collections/LinkedList.js"],"sourcesContent":["define([\"require\", \"exports\", \"../utils/collections/LinkedList\"], function (require, exports, LinkedList_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.StandardClientFactory = void 0;\r\n    class StandardClientFactory {\r\n        messageBrokerClients = new Map();\r\n        static instance;\r\n        constructor() {\r\n        }\r\n        static getInstance() {\r\n            if (StandardClientFactory.instance)\r\n                return StandardClientFactory.instance;\r\n            else\r\n                return (StandardClientFactory.instance = new StandardClientFactory());\r\n        }\r\n        addMessageBrokerClient(key, brokerClient) {\r\n            this.messageBrokerClients.set(key, brokerClient);\r\n        }\r\n        removeMessageBrokerClient(key) {\r\n            if (this.messageBrokerClients)\r\n                this.messageBrokerClients.delete(key);\r\n        }\r\n        getMessageBrokerClient(key) {\r\n            if (this.messageBrokerClients)\r\n                return this.messageBrokerClients.get(key);\r\n            else\r\n                return undefined;\r\n        }\r\n        pendingMessages = new LinkedList_1.LinkedList();\r\n        addToPendingMessage(message) {\r\n            this.pendingMessages.insertLast(message);\r\n        }\r\n        getPendingMessage() {\r\n            return this.pendingMessages;\r\n        }\r\n        clearPendinMessages() {\r\n            console.log('[ Clearing All Pending Messages ]');\r\n            this.pendingMessages = new LinkedList_1.LinkedList();\r\n        }\r\n    }\r\n    exports.StandardClientFactory = StandardClientFactory;\r\n});\r\n","define([\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.ClientType = exports.AckResponseTypes = exports.BrokerTypes = exports.MessageType = exports.ClientDetails = exports.BrokerConf = void 0;\r\n    /** Unless otherwise licensed, the software is our proprietary property and all source code, database,\r\n    * functionality, website design, audio, video, text, photographs and graphics on the site or the product (\r\n    * collectively, the “Content”) and the trademarks, service marks, and logos contained therein ( the\r\n    * “Marks”) are owned or controlled by us or licenses to us, and are protected by the copyright and\r\n    * trademark laws and various other intellectual property rights and unfair competition laws in domestic as\r\n    * well as in foreign jurisdictions and international conventions.\r\n    */\r\n    class BrokerConf {\r\n        fullyQualifiedURL;\r\n        //in case of BrokerType WEB_RTC\r\n        iceServers;\r\n        retryPolicy;\r\n        constructor(fullyQualifiedURL, iceServers, retryPolicy) {\r\n            this.fullyQualifiedURL = fullyQualifiedURL;\r\n            this.iceServers = iceServers;\r\n            this.retryPolicy = retryPolicy;\r\n        }\r\n    }\r\n    exports.BrokerConf = BrokerConf;\r\n    class ClientDetails {\r\n        /**\r\n         * @id client-id\r\n         */\r\n        id;\r\n        /**\r\n         * @name client name\r\n         */\r\n        name;\r\n        /**\r\n         * @additionalDetails clients additional details stored in key:value format like(email or contact-number)\r\n         */\r\n        additionalDetails;\r\n        constructor(id, name, additionalDetails) {\r\n            this.id = id;\r\n            this.name = name;\r\n            this.additionalDetails = additionalDetails;\r\n        }\r\n    }\r\n    exports.ClientDetails = ClientDetails;\r\n    var MessageType;\r\n    (function (MessageType) {\r\n        MessageType[\"CLIENT_TYPE_MESSAGE\"] = \"CLIENT_TYPE_MESSAGE\";\r\n        MessageType[\"CLIENT_INFORMATION_MESSAGE\"] = \"CLIENT_INFORMATION_MESSAGE\";\r\n        MessageType[\"REGISTER_TO_BROKER\"] = \"REGISTER_TO_BROKER\";\r\n        MessageType[\"REGISTERATION_DONE\"] = \"REGISTERATION_DONE\";\r\n        MessageType[\"REGISTERATION_FAILED\"] = \"REGISTERATION_FAILED\";\r\n        MessageType[\"OFFER_REQUESTED\"] = \"OFFER_REQUESTED\";\r\n        MessageType[\"OFFER_REJECTED\"] = \"OFFER_REJECTED\";\r\n        MessageType[\"OFFER_RECEIVED\"] = \"OFFER_RECEIVED\";\r\n        MessageType[\"ANSWER_INITIATED\"] = \"ANSWER_INITIATED\";\r\n        MessageType[\"ANSWER_RECEIVED\"] = \"ANSWER_RECEIVED\";\r\n        MessageType[\"MESSAGE_SEND\"] = \"MESSAGE_SEND\";\r\n        MessageType[\"MESSAGE_RECEIVED\"] = \"MESSAGE_RECEIVED\";\r\n        MessageType[\"MESSAGE_SNEAK\"] = \"MESSAGE_SNEAK\";\r\n        MessageType[\"CLIENT_SESSION_REQUESTED\"] = \"CLIENT_SESSION_REQUESTED\";\r\n        MessageType[\"CLIENT_SESSION_JOINED\"] = \"CLIENT_SESSION_JOINED\";\r\n        MessageType[\"CLIENT_SESSION_LEAVE\"] = \"CLIENT_SESSION_LEAVE\";\r\n        MessageType[\"SESSION_CLOSE_REQUEST\"] = \"SESSION_CLOSE_REQUEST\";\r\n        MessageType[\"SESSION_CLOSED\"] = \"SESSION_CLOSED\";\r\n        MessageType[\"ON_SESSION_CLOSE_REQUEST\"] = \"ON_SESSION_CLOSE_REQUEST\";\r\n        MessageType[\"SESSION_SYNC_REQUEST\"] = \"SESSION_SYNC_REQUEST\";\r\n        MessageType[\"SESSION_SYNC_RESPONSE\"] = \"SESSION_SYNC_RESPONSE\";\r\n        MessageType[\"SESSION_TRANSFER_OFFERED\"] = \"SESSION_TRANSFER_OFFERED\";\r\n        MessageType[\"SESSION_TRANSFER_ACCEPTED\"] = \"SESSION_TRANSFER_ACCEPTED\";\r\n        MessageType[\"SESSION_TRASFER_FAILED\"] = \"SESSION_TRASFER_FAILED\";\r\n        MessageType[\"SESSION_TRANSFER_COMPLEATE\"] = \"SESSION_TRANSFER_COMPLEATE\";\r\n        MessageType[\"LOG\"] = \"LOG\";\r\n        MessageType[\"MESSAGE_ACK\"] = \"MESSAGE_ACK\";\r\n        MessageType[\"ESCALATE_TO_AGENT\"] = \"ESCALATE_TO_AGENT\";\r\n        MessageType[\"ICE_CANDIDATES\"] = \"ICE_CANDIDATES\";\r\n        MessageType[\"CONFIRMATION_ACCEPTED\"] = \"CONFIRMATION_ACCEPTED\";\r\n        MessageType[\"CONFIRMATION_REJECTED\"] = \"CONFIRMATION_REJECTED\";\r\n        MessageType[\"READY_FOR_CALL\"] = \"READY_FOR_CALL\";\r\n        MessageType[\"CALL_INITIATED\"] = \"CALL_INITIATED\";\r\n        MessageType[\"CALL_RESPONSE\"] = \"CALL_RESPONSE\";\r\n        MessageType[\"END_CALL\"] = \"END_CALL\";\r\n        MessageType[\"ON_ICE_CANDIDATES\"] = \"ON_ICE_CANDIDATES\";\r\n        MessageType[\"ROOM_ID_REQUESTED\"] = \"ROOM_ID_REQUESTED\";\r\n        MessageType[\"ON_ROOM_CREATED\"] = \"ON_ROOM_CREATED\";\r\n        MessageType[\"ON_ROOM_CREATION_FAILED\"] = \"ON_ROOM_CREATION_FAILED\";\r\n        MessageType[\"REQUEST_FOR_SUPERVISOR_CHERRY_PICK\"] = \"REQUEST_FOR_SUPERVISOR_CHERRY_PICK\";\r\n        MessageType[\"ON_SUPERVISOR_CHERRY_PICK_SUCCESS\"] = \"ON_SUPERVISOR_CHERRY_PICK_SUCCESS\";\r\n        MessageType[\"ON_SUPERVISOR_CHERRY_PICK_FAILED\"] = \"ON_SUPERVISOR_CHERRY_PICK_FAILED\";\r\n        MessageType[\"REQUEST_FOR_SUPERVISOR_RE_QUEUE\"] = \"REQUEST_FOR_SUPERVISOR_RE_QUEUE\";\r\n        MessageType[\"ON_SUPERVISOR_RE_QUEUE_SUCCESS\"] = \"ON_SUPERVISOR_RE_QUEUE_SUCCESS\";\r\n        MessageType[\"ON_SUPERVISOR_RE_QUEUE_FAILED\"] = \"ON_SUPERVISOR_RE_QUEUE_FAILED\";\r\n    })(MessageType = exports.MessageType || (exports.MessageType = {}));\r\n    /**\r\n     * CXInfinity Available Broker Types\r\n     */\r\n    var BrokerTypes;\r\n    (function (BrokerTypes) {\r\n        BrokerTypes[\"WEB_SOCKET\"] = \"WEB_SOCKET\";\r\n        BrokerTypes[\"HTTP\"] = \"HTTP\";\r\n        BrokerTypes[\"XMPP\"] = \"XMPP\";\r\n        BrokerTypes[\"WEB_RTC\"] = \"WEB_RTC\";\r\n        BrokerTypes[\"BOTTER_INFI\"] = \"BOTTER_INFI\";\r\n    })(BrokerTypes = exports.BrokerTypes || (exports.BrokerTypes = {}));\r\n    var AckResponseTypes;\r\n    (function (AckResponseTypes) {\r\n        AckResponseTypes[\"MESSAGE_RECEIVED\"] = \"MESSAGE_RECEIVED\";\r\n        AckResponseTypes[\"MESSAGE_DELEVERED\"] = \"MESSAGE_DELEVERED\";\r\n        AckResponseTypes[\"ERROR\"] = \"ERROR\";\r\n    })(AckResponseTypes = exports.AckResponseTypes || (exports.AckResponseTypes = {}));\r\n    /**\r\n     * Message broker client type\r\n     * @INDIVIDUAL , If broker client is created to handle single interaction with single client.\r\n     * @BROKER, If broker client is created to handle multiple interaction with single client.\r\n     */\r\n    var ClientType;\r\n    (function (ClientType) {\r\n        ClientType[\"INDIVIDUAL\"] = \"INDIVIDUAL\";\r\n        ClientType[\"BROKER\"] = \"BROKER\";\r\n    })(ClientType = exports.ClientType || (exports.ClientType = {}));\r\n});\r\n","define([\"require\", \"exports\", \"../ClientTypes\", \"../../logger/LoggerFactory\", \"../../client-factory/StandardClientFactory\", \"./BrokerMessage\", \"../../utils/NetworkUtils\", \"./../../utils/ClientUtils\"], function (require, exports, ClientTypes_1, LoggerFactory_1, StandardClientFactory_1, BrokerMessage_1, NetworkUtils_1, ClientUtils_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.AbstractWSMessageBrokerClient = void 0;\r\n    /**\r\n     * Abstract Class used to create Broker client,which is used to make connection with CXInfinity signalling\r\n     * server and helps in sharing messages to server.\r\n     */\r\n    class AbstractWSMessageBrokerClient {\r\n        brokerConnection;\r\n        BROKER_TYPE = ClientTypes_1.BrokerTypes.WEB_SOCKET;\r\n        brokerInterceptor;\r\n        webRTCBrokerInterceptor;\r\n        connectionIsConnected = false;\r\n        clientId;\r\n        clientType = ClientTypes_1.ClientType.INDIVIDUAL;\r\n        logger = LoggerFactory_1.LoggerFactory.getLogger(this);\r\n        messageReceivedCallBack;\r\n        messageDeliveredCallBack;\r\n        loadUpConf;\r\n        constructor(clientId, loadUpConf, brokerInterceptor, clientType) {\r\n            this.clientId = clientId;\r\n            this.loadUpConf = loadUpConf;\r\n            this.configureClient();\r\n            if (brokerInterceptor)\r\n                this.brokerInterceptor = brokerInterceptor;\r\n            if (clientType)\r\n                this.clientType = clientType;\r\n            NetworkUtils_1.NetworkUtils.onNetworkConnect(this.onLANConnected);\r\n        }\r\n        onLANConnected = () => {\r\n            console.log(' %c = = LAN CONNECTED = =', 'font-weight: bold; font-size: 40px;color: red; text-shadow: 3px 3px 0 rgb(217,31,38) , 6px 6px 0 rgb(226,91,14) , 9px 9px 0 rgb(245,221,8) , 12px 12px 0 rgb(5,148,68) , 15px 15px 0 rgb(2,135,206) , 18px 18px 0 rgb(4,77,145) , 21px 21px 0 rgb(42,21,113)');\r\n            if (!this.isConnected()) {\r\n                console.log(' ----- WEBSCOCKET ALREADY CONNECTED ----- ');\r\n            }\r\n            else\r\n                this.connectToWebsocket();\r\n        };\r\n        configureClient() {\r\n            this.connectToWebsocket();\r\n        }\r\n        connectToWebsocket() {\r\n            if (!this.brokerConnection\r\n                || this.brokerConnection.readyState != WebSocket.CONNECTING\r\n                || this.brokerConnection.readyState != WebSocket.OPEN) {\r\n                this.logger.info(' Connecting to WS Server : ' + this.loadUpConf.fullyQualifiedURL);\r\n                if (this.brokerConnection)\r\n                    this.disconnect(true);\r\n                this.brokerConnection = new WebSocket(this.loadUpConf.fullyQualifiedURL);\r\n                this.registerCallBack(this.loadUpConf);\r\n            }\r\n        }\r\n        retryConnectionVal;\r\n        startRetryThread(loadUpConf) {\r\n            clearTimeout(this.retryConnectionVal);\r\n            if (loadUpConf.retryPolicy) {\r\n                this.retryConnectionVal = setInterval(this.retryConnection.\r\n                    bind(this, loadUpConf), loadUpConf.retryPolicy.reconnectInterval);\r\n            }\r\n            else {\r\n                this.retryConnectionVal = setInterval(this.retryConnection.\r\n                    bind(this, loadUpConf), 10000);\r\n            }\r\n        }\r\n        registerCallBack(loadUpConf) {\r\n            if (this.brokerConnection) {\r\n                this.brokerConnection.onclose = (event) => {\r\n                    this.logger.info(\"WebSocket Client Connection Closed\");\r\n                    this.retryAttempts = 0;\r\n                    this.disconnect(true);\r\n                    StandardClientFactory_1.StandardClientFactory.getInstance().\r\n                        removeMessageBrokerClient(loadUpConf.fullyQualifiedURL);\r\n                    if (this.brokerInterceptor)\r\n                        this.brokerInterceptor.onDisconnect(event);\r\n                    this.startRetryThread(loadUpConf);\r\n                };\r\n                this.brokerConnection.onopen = (event) => {\r\n                    this.logger.info(\"WebSocket Client Connection Open\");\r\n                    this.connectionIsConnected = true;\r\n                    this.updateClientTypeToServer();\r\n                    StandardClientFactory_1.StandardClientFactory.getInstance().\r\n                        addMessageBrokerClient(loadUpConf.fullyQualifiedURL, this);\r\n                    this.retryPendingMessages();\r\n                    if (this.brokerInterceptor)\r\n                        this.brokerInterceptor.onConnect(event);\r\n                };\r\n                this.brokerConnection.onerror = (event) => {\r\n                    console.error(\"Error Occurred,\", event);\r\n                    if (this.brokerInterceptor)\r\n                        this.brokerInterceptor.onError(event);\r\n                };\r\n                this.brokerConnection.onmessage = (event) => {\r\n                    if (event && this.brokerConnection && event.data == 'PING') {\r\n                        this.brokerConnection.send(\"PONG\");\r\n                        this.heartBeat();\r\n                    }\r\n                    else if (event && this.brokerConnection && event.data.toString().includes(\"ip-address\")) {\r\n                        var ipAddress = event.data.split(\":\")[1];\r\n                        this.brokerInterceptor.onIPAddressReceive(ipAddress);\r\n                    }\r\n                    else if (event)\r\n                        this.onMessage(event);\r\n                    else\r\n                        console.log(' BAD_MESSAGE : [ On Message Receive ] ');\r\n                };\r\n            }\r\n        }\r\n        heatBeatInterval = 0;\r\n        heartBeat() {\r\n            clearTimeout(this.heatBeatInterval);\r\n            this.heatBeatInterval = setTimeout(() => {\r\n                this.disconnect(true);\r\n            }, 8000 + 2000);\r\n            StandardClientFactory_1.StandardClientFactory.getInstance().clearPendinMessages();\r\n        }\r\n        updateClientTypeToServer() {\r\n            let data = {};\r\n            data['clientType'] = this.clientType;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(), ClientTypes_1.MessageType.CLIENT_TYPE_MESSAGE, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        publishClientInfo(customerDetails) {\r\n            let data = {};\r\n            data['customerDetails'] = customerDetails;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(customerDetails.id), ClientTypes_1.MessageType.CLIENT_INFORMATION_MESSAGE, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        registerNewReqToBroker(customerDetails, saveInGarageOnly) {\r\n            let data = {};\r\n            data['customerDetails'] = customerDetails;\r\n            if (saveInGarageOnly && saveInGarageOnly == true)\r\n                data['saveInGarageOnly'] = saveInGarageOnly;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(), ClientTypes_1.MessageType.REGISTER_TO_BROKER, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        registerExistingReqToBroker(interactionId) {\r\n            let data = {};\r\n            data['customerDetails'] = { interactionId: interactionId };\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(), ClientTypes_1.MessageType.REGISTER_TO_BROKER, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        readyForSession(sessionId, sender) {\r\n            let data = {};\r\n            data['sessionId'] = sessionId;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(sender), ClientTypes_1.MessageType.CLIENT_SESSION_JOINED, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        requestClientSession(sessionId, sender) {\r\n            let data = {};\r\n            data['sessionId'] = sessionId;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(sender), ClientTypes_1.MessageType.CLIENT_SESSION_REQUESTED, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        syncSession(sessionId, sender) {\r\n            let data = {};\r\n            data['sessionId'] = sessionId;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(sender), ClientTypes_1.MessageType.SESSION_SYNC_REQUEST, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        closeSession(sessionId, sender, initiatingToClose) {\r\n            let data = {};\r\n            data['sessionId'] = sessionId;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(sender), initiatingToClose ? ClientTypes_1.MessageType.SESSION_CLOSE_REQUEST : ClientTypes_1.MessageType.SESSION_CLOSED, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        sendAck(sessionId, messageId) {\r\n            let data = {};\r\n            data['ackResType'] = ClientTypes_1.AckResponseTypes.MESSAGE_DELEVERED;\r\n            data['sessionId'] = sessionId;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.clientId, ClientTypes_1.MessageType.MESSAGE_ACK, data);\r\n            this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        makeOffer(interactionId, supportedBrokerTypes, senderDetails) {\r\n            let data = {};\r\n            data['interactionId'] = interactionId;\r\n            data['supportedBrokerTypes'] = supportedBrokerTypes;\r\n            data['senderDetails'] = senderDetails;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(senderDetails.id), ClientTypes_1.MessageType.OFFER_REQUESTED, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        createAnswer(interactionId, supportedBrokerTypes, sender) {\r\n            let data = {};\r\n            data['interactionId'] = interactionId;\r\n            data['supportedBrokerTypes'] = supportedBrokerTypes;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(sender), ClientTypes_1.MessageType.ANSWER_INITIATED, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        sendMessage(sessionId, message, sender, onMessageReceiveCallback, onMessageDeliveredCallback) {\r\n            try {\r\n                let data = {};\r\n                data['sessionId'] = sessionId;\r\n                data['message'] = message;\r\n                let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(sender), ClientTypes_1.MessageType.MESSAGE_SEND, data);\r\n                if (onMessageReceiveCallback) {\r\n                    this.addToMessageReceiveCallback(brokerMessage.messageKey, onMessageReceiveCallback);\r\n                }\r\n                if (onMessageDeliveredCallback) {\r\n                    this.addToMessageDeliveredCallback(brokerMessage.messageKey, onMessageDeliveredCallback);\r\n                }\r\n                return this.sendMessageToBroker(brokerMessage);\r\n            }\r\n            catch (error) {\r\n                this.logger.error(error);\r\n            }\r\n            return \"\";\r\n        }\r\n        sendSneakMessage(sessionId, message, sender) {\r\n            try {\r\n                let data = {};\r\n                data['sessionId'] = sessionId;\r\n                data['message'] = message;\r\n                let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(sender), ClientTypes_1.MessageType.MESSAGE_SNEAK, data);\r\n                return this.sendMessageToBroker(brokerMessage);\r\n            }\r\n            catch (error) {\r\n                this.logger.error(error);\r\n            }\r\n            return \"\";\r\n        }\r\n        addToMessageReceiveCallback(key, value) {\r\n            if (!this.messageReceivedCallBack)\r\n                this.messageReceivedCallBack = new Map();\r\n            this.messageReceivedCallBack.set(key, value);\r\n        }\r\n        addToMessageDeliveredCallback(key, value) {\r\n            if (!this.messageDeliveredCallBack)\r\n                this.messageDeliveredCallBack = new Map();\r\n            this.messageDeliveredCallBack.set(key, value);\r\n        }\r\n        getSenderId(sender) {\r\n            if (sender)\r\n                return sender;\r\n            else\r\n                return this.clientId;\r\n        }\r\n        sendMessageToBroker(message) {\r\n            if (message) {\r\n                if (message.messageType == ClientTypes_1.MessageType.MESSAGE_SEND\r\n                    ||\r\n                        message.messageType == ClientTypes_1.MessageType.SESSION_CLOSE_REQUEST\r\n                    ||\r\n                        message.messageType == ClientTypes_1.MessageType.END_CALL) {\r\n                    StandardClientFactory_1.StandardClientFactory.getInstance().addToPendingMessage(message);\r\n                }\r\n            }\r\n            if (message && this.isConnected() && this.brokerConnection) {\r\n                this.brokerConnection.send(JSON.stringify(message));\r\n                return message.messageKey;\r\n            }\r\n            else if (message && message.messageType != ClientTypes_1.MessageType.MESSAGE_SNEAK) {\r\n                this.startRetryThread(this.loadUpConf);\r\n                throw new Error(\" Broker is not ready for Ws-Client : \" + this.clientId);\r\n            }\r\n            else {\r\n                throw new Error(\" Broker is not ready for Ws-Client : \" + this.clientId);\r\n            }\r\n            return \"\";\r\n        }\r\n        isConnected() {\r\n            return this.connectionIsConnected &&\r\n                (this.brokerConnection != null) &&\r\n                (this.brokerConnection.readyState === WebSocket.OPEN);\r\n        }\r\n        retryAttempts = 0;\r\n        retryConnection(loadUpConf) {\r\n            if (this.isConnected()) {\r\n                clearTimeout(this.retryConnectionVal);\r\n                return;\r\n            }\r\n            else {\r\n                if (loadUpConf.retryPolicy) {\r\n                    let isToInitiateReconnect = true;\r\n                    if (isToInitiateReconnect) {\r\n                        this.logger.trace(' Attempting retry to WebSocket Server for Ws-Client '\r\n                            + this.clientId);\r\n                        this.retryAttempts++;\r\n                        this.connectToWebsocket();\r\n                    }\r\n                }\r\n                else {\r\n                    this.logger.trace(' Retry Policy Not Found for Ws-Client : ' + this.clientId);\r\n                }\r\n            }\r\n        }\r\n        isOnlyForWebRTC(message) {\r\n            return (message.data && message.data['message'] && message.data['message']['callType'])\r\n                || message.brokerType == ClientTypes_1.BrokerTypes.WEB_RTC;\r\n        }\r\n        onMessage(event) {\r\n            try {\r\n                let message = JSON.parse(event.data);\r\n                if (this.webRTCBrokerInterceptor)\r\n                    this.webRTCBrokerInterceptor.onMessage(message);\r\n                if (this.isOnlyForWebRTC(message)) {\r\n                    return;\r\n                }\r\n                switch (message.messageType) {\r\n                    case ClientTypes_1.MessageType.REGISTERATION_DONE:\r\n                        let registerationKey = message.messageKey;\r\n                        let interactionId = message.data['interactionId'];\r\n                        let saveInGarageOnly = message.data['saveInGarageOnly'];\r\n                        let sessionIdVal = message.data['sessionId'];\r\n                        if (this.brokerInterceptor) {\r\n                            this.brokerInterceptor.\r\n                                onRegisterationSuccessfull(registerationKey, interactionId, sessionIdVal, saveInGarageOnly);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.REGISTERATION_FAILED:\r\n                        if (this.brokerInterceptor) {\r\n                            let failedReason = message.data['failedReason'];\r\n                            let registerationKey = message.messageKey;\r\n                            this.brokerInterceptor.\r\n                                onRegisterationFail(registerationKey, failedReason);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.OFFER_RECEIVED:\r\n                        if (this.brokerInterceptor) {\r\n                            let interactionId = message.data['interactionId'];\r\n                            let senderDetails = message.data['senderDetails'];\r\n                            this.brokerInterceptor.\r\n                                onOfferReceive(interactionId, senderDetails);\r\n                            this.createAnswer(interactionId, ClientUtils_1.ClientUtils.getSupportedMediaBroker(), interactionId);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.OFFER_REJECTED:\r\n                        if (this.brokerInterceptor) {\r\n                            let interactionId = message.data['interactionId'];\r\n                            let sessionId = message.data['sessionId'];\r\n                            let rejectedReason = message.data['rejectedReason'];\r\n                            this.brokerInterceptor.\r\n                                onOfferRejected(interactionId, sessionId, rejectedReason);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.SESSION_TRANSFER_OFFERED:\r\n                        if (this.brokerInterceptor) {\r\n                            this.brokerInterceptor.\r\n                                onSessionTransferOffered(message.data);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.SESSION_TRANSFER_ACCEPTED:\r\n                        if (this.brokerInterceptor) {\r\n                            let sessionId = message.data['sessionId'];\r\n                            let agentId = message.data['agentId'];\r\n                            this.brokerInterceptor.\r\n                                onSessionTransferAccepted(sessionId, agentId);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.SESSION_TRASFER_FAILED:\r\n                        if (this.brokerInterceptor) {\r\n                            let sessionId = message.data['sessionId'];\r\n                            let failedReason = message.data['failedReason'];\r\n                            this.brokerInterceptor.\r\n                                onSessionTransferFailed(sessionId, failedReason);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.SESSION_TRANSFER_COMPLEATE:\r\n                        if (this.brokerInterceptor) {\r\n                            let sessionId = message.data['sessionId'];\r\n                            let transferTo = message.data['transferTo'];\r\n                            let transferToDetails = message.data['transferToDetails'];\r\n                            this.brokerInterceptor.\r\n                                onSessionTransferCompleate(sessionId, transferTo, transferToDetails);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.ANSWER_RECEIVED:\r\n                        if (this.brokerInterceptor) {\r\n                            let interactionId = message.data['interactionId'];\r\n                            let sessionId = message.data['sessionId'];\r\n                            let supportedBrokerType = message.data['supportedBrokerType'];\r\n                            let brokerConf = message.data['brokerConf'];\r\n                            this.brokerInterceptor.onAnswerReceive(interactionId, sessionId, supportedBrokerType, brokerConf);\r\n                            this.syncSession(sessionId, this.getClientId());\r\n                            this.readyForSession(sessionId, this.getClientId());\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.MESSAGE_RECEIVED:\r\n                        // this.sendAck(message.data['sessionId'], message.messageKey);\r\n                        if (this.brokerInterceptor) {\r\n                            let messageData = message.data;\r\n                            this.brokerInterceptor.onMessageReceive(messageData);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.MESSAGE_SNEAK:\r\n                        if (this.brokerInterceptor) {\r\n                            let messageData = message.data;\r\n                            this.brokerInterceptor.onSeakMessage(messageData);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.CLIENT_SESSION_JOINED:\r\n                        if (this.brokerInterceptor) {\r\n                            let sessionId = message.data['sessionId'];\r\n                            let clientDetails = message.data['clientDetails'];\r\n                            this.brokerInterceptor.onClientSessionJoin(sessionId, clientDetails);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.CLIENT_SESSION_LEAVE:\r\n                        if (this.brokerInterceptor) {\r\n                            const sessionId = message.data['sessionId'];\r\n                            let clientId = message.data['clientId'];\r\n                            this.brokerInterceptor.onClientSessionLeave(sessionId, clientId);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.SESSION_SYNC_RESPONSE:\r\n                        if (this.brokerInterceptor) {\r\n                            this.brokerInterceptor.onSessionSync(message.data);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.CLIENT_SESSION_REQUESTED:\r\n                        {\r\n                            let sessionId = message.data['sessionId'];\r\n                            this.readyForSession(sessionId, this.getClientId());\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.ON_SESSION_CLOSE_REQUEST:\r\n                        if (this.brokerInterceptor) {\r\n                            //let sessionId:string = message.data['sessionId'];\r\n                            this.brokerInterceptor.onSessionClose(message.data);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.MESSAGE_ACK:\r\n                        if (this.brokerInterceptor) {\r\n                            let messageKey = message.messageKey;\r\n                            let ackResponseTypes = message.data['ackResType'];\r\n                            this.findAndInvokeAckCallbacks(messageKey, ackResponseTypes, message);\r\n                            let error = message.data['error'];\r\n                            if (error)\r\n                                this.brokerInterceptor.ack(messageKey, ackResponseTypes, error);\r\n                            else\r\n                                this.brokerInterceptor.ack(messageKey, ackResponseTypes);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.ESCALATE_TO_AGENT:\r\n                        let sessionId = message.data['sessionId'];\r\n                        let customerPayload = message.data;\r\n                        console.log(' [ESCALATE_TO_AGENT] Message received ', message);\r\n                        if (this.brokerInterceptor)\r\n                            this.brokerInterceptor.escalateToAgent(sessionId, customerPayload);\r\n                        break;\r\n                    case ClientTypes_1.MessageType.ON_SUPERVISOR_CHERRY_PICK_SUCCESS:\r\n                        {\r\n                            let sessionId = message.data['sessionId'];\r\n                            let agentId = message.data['agentId'];\r\n                            console.log(' [ON_SUPERVISOR_CHERRY_PICK_SUCCESS] Message received ', message);\r\n                            if (this.brokerInterceptor && this.brokerInterceptor.onSuperVisorCherryPickSuccess)\r\n                                this.brokerInterceptor.onSuperVisorCherryPickSuccess(sessionId, agentId);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.ON_SUPERVISOR_CHERRY_PICK_FAILED:\r\n                        {\r\n                            let sessionId = message.data['sessionId'];\r\n                            let agentId = message.data['agentId'];\r\n                            let failedReason = message.data['failedReason'];\r\n                            console.log(' [ON_SUPERVISOR_CHERRY_PICK_FAILED] Message received ', message);\r\n                            if (this.brokerInterceptor && this.brokerInterceptor.onSuperVisorCherryPickFailed)\r\n                                this.brokerInterceptor.onSuperVisorCherryPickFailed(sessionId, agentId, failedReason);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.ON_SUPERVISOR_RE_QUEUE_SUCCESS:\r\n                        {\r\n                            let sessionId = message.data['sessionId'];\r\n                            let queueName = message.data['queueName'];\r\n                            console.log(' [ON_SUPERVISOR_RE_QUEUE_SUCCESS] Message received ', message);\r\n                            if (this.brokerInterceptor && this.brokerInterceptor.onSuperVisorReQueueSuccess)\r\n                                this.brokerInterceptor.onSuperVisorReQueueSuccess(sessionId, queueName);\r\n                        }\r\n                        break;\r\n                    case ClientTypes_1.MessageType.ON_SUPERVISOR_RE_QUEUE_FAILED:\r\n                        {\r\n                            let sessionId = message.data['sessionId'];\r\n                            let queueName = message.data['queueName'];\r\n                            let failedReason = message.data['failedReason'];\r\n                            console.log(' [ON_SUPERVISOR_RE_QUEUE_FAILED] Message received ', message);\r\n                            if (this.brokerInterceptor && this.brokerInterceptor.onSuperVisorReQueueFailed)\r\n                                this.brokerInterceptor.onSuperVisorReQueueFailed(sessionId, queueName, failedReason);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        this.logger.error('MessageType : <' + message.messageType +\r\n                            '> not Supported for Ws-Client : ' + this.clientId);\r\n                        break;\r\n                }\r\n            }\r\n            catch (error) {\r\n                this.logger.error('Error Occurred While Parsing Message for Ws-Client : '\r\n                    + this.clientId\r\n                    + ' ,' + error);\r\n            }\r\n        }\r\n        retryPendingMessages() {\r\n            try {\r\n                let pendingMessages = StandardClientFactory_1.StandardClientFactory\r\n                    .getInstance().\r\n                    getPendingMessage();\r\n                if (pendingMessages && !pendingMessages.isEmpty()) {\r\n                    let message = null;\r\n                    while (!pendingMessages.isEmpty() &&\r\n                        (message = pendingMessages.removeFirst()) != null) {\r\n                        try {\r\n                            if (this.brokerConnection)\r\n                                this.brokerConnection.send(JSON.stringify(message));\r\n                        }\r\n                        catch (error) {\r\n                            StandardClientFactory_1.StandardClientFactory.getInstance().addToPendingMessage(message);\r\n                            throw error;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                this.logger.debug('[ERROR while retrying failed massages] ' + error);\r\n            }\r\n        }\r\n        findAndInvokeAckCallbacks(messageKey, ackResponseTypes, message) {\r\n            if (ClientTypes_1.AckResponseTypes.MESSAGE_DELEVERED == ackResponseTypes\r\n                && this.messageDeliveredCallBack) {\r\n                let callback = this.messageDeliveredCallBack.get(messageKey);\r\n                if (callback) {\r\n                    callback.bind(this, message)();\r\n                }\r\n            }\r\n            if (ClientTypes_1.AckResponseTypes.MESSAGE_RECEIVED == ackResponseTypes\r\n                && this.messageReceivedCallBack) {\r\n                let callback = this.messageReceivedCallBack.get(messageKey);\r\n                if (callback) {\r\n                    callback.bind(this, message)();\r\n                }\r\n            }\r\n        }\r\n        updateClientId(clientId) {\r\n            this.clientId = clientId;\r\n        }\r\n        getClientId() {\r\n            return this.clientId;\r\n        }\r\n        disconnect(isToApplyRetryAgain) {\r\n            console.log(' [ CLIENT DISCONNECTED ] ');\r\n            if (!isToApplyRetryAgain)\r\n                this.loadUpConf.retryPolicy = undefined;\r\n            if (this.brokerConnection) {\r\n                this.connectionIsConnected = false;\r\n                this.brokerConnection.close();\r\n                this.brokerConnection = null;\r\n            }\r\n        }\r\n        requestTransfer(sessionId, agentToOffer, agentName, additionalData, senderId) {\r\n            let data = {};\r\n            data['sessionId'] = sessionId;\r\n            data['agentToOffer'] = agentToOffer;\r\n            data['agentName'] = agentName;\r\n            data['additionalData'] = additionalData;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(senderId), ClientTypes_1.MessageType.SESSION_TRANSFER_OFFERED, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        transferRequestAccepted(sessionId, senderId) {\r\n            let data = {};\r\n            data['sessionId'] = sessionId;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(senderId), ClientTypes_1.MessageType.SESSION_TRANSFER_ACCEPTED, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        transferRequestRejected(sessionId, rejectedReason) {\r\n            let data = {};\r\n            data['sessionId'] = sessionId;\r\n            data['rejectedReason'] = rejectedReason;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(), ClientTypes_1.MessageType.SESSION_TRASFER_FAILED, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        requestCherryPick(customerDetails, transferTo, sender) {\r\n            let data = {};\r\n            data['customerDetails'] = customerDetails;\r\n            data['transferTo'] = transferTo;\r\n            data['sender'] = sender;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(sender), ClientTypes_1.MessageType.REQUEST_FOR_SUPERVISOR_CHERRY_PICK, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        requestReQueue(customerDetails, requeDetails, sender) {\r\n            let data = {};\r\n            data['customerDetails'] = customerDetails;\r\n            data['requeDetails'] = requeDetails;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(sender), ClientTypes_1.MessageType.REQUEST_FOR_SUPERVISOR_RE_QUEUE, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        transferSuccessFull(sessionId, transferTo, sender) {\r\n            let data = {};\r\n            data['sessionId'] = sessionId;\r\n            data['transferTo'] = transferTo;\r\n            let brokerMessage = new BrokerMessage_1.BrokerMessage(this.BROKER_TYPE, this.getSenderId(sender), ClientTypes_1.MessageType.SESSION_TRANSFER_COMPLEATE, data);\r\n            return this.sendMessageToBroker(brokerMessage);\r\n        }\r\n        registerWebRTCBrokerInterceptor(webRTCBrokerInterceptor) {\r\n            this.webRTCBrokerInterceptor = webRTCBrokerInterceptor;\r\n        }\r\n    }\r\n    exports.AbstractWSMessageBrokerClient = AbstractWSMessageBrokerClient;\r\n});\r\n","define([\"require\", \"exports\", \"../../utils/ClientUtils\"], function (require, exports, ClientUtils_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.BrokerMessage = void 0;\r\n    /**\r\n     * Broker Message Template which is shared between CXInfinity broker client and CXInfinity\r\n     * signalling server.\r\n     */\r\n    class BrokerMessage {\r\n        brokerType;\r\n        sender;\r\n        messageType;\r\n        /**\r\n         *\r\n         */\r\n        messageKey;\r\n        /**\r\n         * shared data like structure @ChatMessageBody\r\n         */\r\n        data;\r\n        /**\r\n         * generated message timestamp\r\n         */\r\n        timestamp;\r\n        constructor(brokerType, sender, messageType, data) {\r\n            this.brokerType = brokerType;\r\n            this.sender = sender;\r\n            this.messageType = messageType;\r\n            this.messageKey = ClientUtils_1.ClientUtils.generateUniqueKey();\r\n            this.data = data;\r\n            this.timestamp = new Date().getTime();\r\n        }\r\n    }\r\n    exports.BrokerMessage = BrokerMessage;\r\n});\r\n","define([\"require\", \"exports\", \"./AbstractWSMessageBrokerClient\"], function (require, exports, AbstractWSMessageBrokerClient_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.StanderdWSMessageBrokerClient = void 0;\r\n    class StanderdWSMessageBrokerClient extends AbstractWSMessageBrokerClient_1.AbstractWSMessageBrokerClient {\r\n        constructor(clientId, loadUpConf, brokerInterceptor) {\r\n            super(clientId, loadUpConf, brokerInterceptor);\r\n        }\r\n    }\r\n    exports.StanderdWSMessageBrokerClient = StanderdWSMessageBrokerClient;\r\n});\r\n","define([\"require\", \"exports\", \"../client/ClientTypes\", \"../client/websocket/BrokerMessage\"], function (require, exports, ClientTypes_1, BrokerMessage_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.LoggerType = exports.Logger = void 0;\r\n    window['logger'] = {\r\n        'INFO': true,\r\n        'DEBUG': true,\r\n        'TRACE': false,\r\n    };\r\n    class Logger {\r\n        messageBrokerClient;\r\n        constructor(messageBrokerClient) {\r\n            if (messageBrokerClient) {\r\n                this.messageBrokerClient = messageBrokerClient;\r\n            }\r\n        }\r\n        info(message, sessionId) {\r\n            if (window['logger'][LoggerType.INFO]) {\r\n                console.info(message);\r\n                try {\r\n                    if (this.messageBrokerClient && this.messageBrokerClient.isConnected()) {\r\n                        this.messageBrokerClient.\r\n                            sendMessageToBroker(this.constructTemplate(LoggerType.INFO, message, sessionId));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    console.error('error sending message to MessageBroker ' + error);\r\n                }\r\n            }\r\n        }\r\n        error(message, sessionId) {\r\n            console.error(message);\r\n            try {\r\n                if (this.messageBrokerClient && this.messageBrokerClient.isConnected()) {\r\n                    this.messageBrokerClient.\r\n                        sendMessageToBroker(this.constructTemplate(LoggerType.ERROR, message, sessionId));\r\n                }\r\n            }\r\n            catch (error) {\r\n                console.error('error sending message to MessageBroker ' + error);\r\n            }\r\n        }\r\n        trace(message, sessionId) {\r\n            if (window['logger'][LoggerType.TRACE]) {\r\n                console.trace(message);\r\n                try {\r\n                    if (this.messageBrokerClient && this.messageBrokerClient.isConnected()) {\r\n                        this.messageBrokerClient.\r\n                            sendMessageToBroker(this.constructTemplate(LoggerType.TRACE, message, sessionId));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    console.error('error sending message to MessageBroker ' + error);\r\n                }\r\n            }\r\n        }\r\n        debug(message, sessionId) {\r\n            if (window['logger'][LoggerType.DEBUG]) {\r\n                console.debug(message);\r\n                try {\r\n                    if (this.messageBrokerClient && this.messageBrokerClient.isConnected()) {\r\n                        this.messageBrokerClient.\r\n                            sendMessageToBroker(this.constructTemplate(LoggerType.DEBUG, message, sessionId));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    console.error('error sending message to MessageBroker ' + error);\r\n                }\r\n            }\r\n        }\r\n        constructTemplate(loggerType, msg, sessionId) {\r\n            let messageData = Object.create(null);\r\n            messageData['logType'] = loggerType;\r\n            messageData['message'] = msg;\r\n            if (sessionId)\r\n                messageData['sessionId'] = sessionId;\r\n            let message = new BrokerMessage_1.BrokerMessage(ClientTypes_1.BrokerTypes.WEB_SOCKET, sessionId ? sessionId : this.messageBrokerClient.getClientId(), ClientTypes_1.MessageType.LOG, messageData);\r\n            return message;\r\n        }\r\n    }\r\n    exports.Logger = Logger;\r\n    var LoggerType;\r\n    (function (LoggerType) {\r\n        LoggerType[\"INFO\"] = \"INFO\";\r\n        LoggerType[\"DEBUG\"] = \"DEBUG\";\r\n        LoggerType[\"ERROR\"] = \"ERROR\";\r\n        LoggerType[\"TRACE\"] = \"TRACE\";\r\n    })(LoggerType = exports.LoggerType || (exports.LoggerType = {}));\r\n});\r\n","define([\"require\", \"exports\", \"./Logger\"], function (require, exports, Logger_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.LoggerFactory = void 0;\r\n    class LoggerFactory {\r\n        constructor() {\r\n        }\r\n        static getLogger(brokerClient) {\r\n            return new Logger_1.Logger(brokerClient);\r\n        }\r\n    }\r\n    exports.LoggerFactory = LoggerFactory;\r\n});\r\n","define([\"require\", \"exports\", \"../client/ClientTypes\"], function (require, exports, ClientTypes_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.DS = exports.ClientUtils = void 0;\r\n    class ClientUtils {\r\n        constructor() { }\r\n        static getSupportedMessageDataBroker() {\r\n            return [ClientTypes_1.BrokerTypes.WEB_SOCKET];\r\n        }\r\n        static getSupportedMediaBroker() {\r\n            return [ClientTypes_1.BrokerTypes.WEB_RTC, ClientTypes_1.BrokerTypes.WEB_SOCKET, ClientTypes_1.BrokerTypes.WEB_SOCKET];\r\n        }\r\n        static generateUniqueKey() {\r\n            return (Date.now().toString(36)\r\n                + Math.random().toString(36).\r\n                    substr(2, 5)).toUpperCase();\r\n        }\r\n    }\r\n    exports.ClientUtils = ClientUtils;\r\n    var DS;\r\n    (function (DS) {\r\n        class Node {\r\n            item;\r\n            next;\r\n            constructor(item = null) {\r\n                this.item = item;\r\n                this.next = null;\r\n            }\r\n        }\r\n        DS.Node = Node;\r\n    })(DS = exports.DS || (exports.DS = {}));\r\n});\r\n","define([\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.NetworkUtils = void 0;\r\n    /** Unless otherwise licensed, the software is our proprietary property and all source code, database,\r\n    * functionality, website design, audio, video, text, photographs and graphics on the site or the product (\r\n    * collectively, the “Content”) and the trademarks, service marks, and logos contained therein ( the\r\n    * “Marks”) are owned or controlled by us or licenses to us, and are protected by the copyright and\r\n    * trademark laws and various other intellectual property rights and unfair competition laws in domestic as\r\n    * well as in foreign jurisdictions and international conventions.\r\n    */\r\n    /**\r\n     * A Utility used as network connection and disconnection intimation to message-broker-client.\r\n     */\r\n    class NetworkUtils {\r\n        constructor() { }\r\n        static DISCONNECT_LIST = new Array();\r\n        static CONNECT_LIST = new Array();\r\n        static onNetworkDisconnect(callBack) {\r\n            NetworkUtils.DISCONNECT_LIST.push(callBack);\r\n        }\r\n        static onNetworkConnect(callBack) {\r\n            NetworkUtils.CONNECT_LIST.push(callBack);\r\n        }\r\n        static networkConnected() {\r\n            NetworkUtils.CONNECT_LIST.forEach((callBack) => {\r\n                try {\r\n                    callBack();\r\n                }\r\n                catch (error) {\r\n                    console.error(\" [ ERROR ON LAN CONNECTED ] \", error);\r\n                }\r\n            });\r\n        }\r\n        static networkDisconnected() {\r\n            NetworkUtils.DISCONNECT_LIST.forEach((callBack) => {\r\n                try {\r\n                    callBack();\r\n                }\r\n                catch (error) {\r\n                    console.error(\" [ ERROR ON LAN DISCONNECTED ] \", error);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    exports.NetworkUtils = NetworkUtils;\r\n});\r\n","define([\"require\", \"exports\", \"../ClientUtils\"], function (require, exports, ClientUtils_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.LinkedList = void 0;\r\n    class LinkedList {\r\n        head;\r\n        tail;\r\n        constructor() {\r\n            this.head = new ClientUtils_1.DS.Node();\r\n            this.tail = new ClientUtils_1.DS.Node();\r\n            this.head.next = this.tail;\r\n        }\r\n        isEmpty() {\r\n            return this.head.next === this.tail;\r\n        }\r\n        insertFirst(item) {\r\n            // Encapsulate our item into a Node object\r\n            const newNode = new ClientUtils_1.DS.Node(item);\r\n            newNode.next = this.head.next;\r\n            this.head.next = newNode;\r\n        }\r\n        insertLast(item) {\r\n            const newNode = new ClientUtils_1.DS.Node(item);\r\n            let cur = this.head;\r\n            // Advance our cur pointer to just before the tail node\r\n            while (cur && cur.next !== this.tail) {\r\n                cur = cur.next;\r\n            }\r\n            if (cur) {\r\n                newNode.next = this.tail;\r\n                cur.next = newNode;\r\n            }\r\n        }\r\n        removeFirst() {\r\n            if (this.isEmpty()) {\r\n                throw new Error('List is empty');\r\n            }\r\n            let rv = this.head.next;\r\n            if (rv) {\r\n                this.head.next = rv.next;\r\n                rv.next = null;\r\n            }\r\n            // We are returning the data, not the node itself\r\n            return rv ? rv.item : null;\r\n        }\r\n        remove(searchKey) {\r\n            if (this.isEmpty()) {\r\n                throw new Error('List is empty');\r\n            }\r\n            // rv = retval or return value\r\n            let rv = null;\r\n            // cur = current\r\n            let cur = this.head;\r\n            // Advance our cur pointer to the node right before our matching node\r\n            while (cur.next && cur.next.item !== searchKey) {\r\n                cur = cur.next;\r\n            }\r\n            if (cur.next) {\r\n                rv = cur.next;\r\n                cur.next = cur.next.next;\r\n                rv.next = null;\r\n            }\r\n            return rv && rv.item ? rv.item : null;\r\n        }\r\n        contains(searchItem) {\r\n            if (this.isEmpty()) {\r\n                throw new Error('List is empty');\r\n            }\r\n            let rv = false;\r\n            let cur = this.head;\r\n            // Traverse the list in search of a matching item\r\n            while (cur && cur.next !== this.tail) {\r\n                if (cur.next && cur.next.item === searchItem) {\r\n                    rv = true;\r\n                    break;\r\n                }\r\n                cur = cur.next;\r\n            }\r\n            return rv;\r\n        }\r\n        getFirst() {\r\n            if (this.isEmpty()) {\r\n                throw new Error('List is empty');\r\n            }\r\n            return this.head.next ? this.head.next.item : null;\r\n        }\r\n        listContents() {\r\n            let cur = this.head.next;\r\n            while (cur && cur !== this.tail) {\r\n                console.log(`${cur.item}`);\r\n                cur = cur.next;\r\n            }\r\n        }\r\n    }\r\n    exports.LinkedList = LinkedList;\r\n});\r\n"],"names":[],"sourceRoot":""}